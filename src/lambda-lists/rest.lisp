(in-package :adhoc-polymorphic-functions)

(defmethod %lambda-list-type ((type (eql 'rest)) (lambda-list list))
  (let ((state :required))
    (dolist (elt lambda-list)
      (ecase state
        (:required (cond ((eq elt '&rest)
                          (setf state '&rest))
                         ((and *lambda-list-typed-p*   (listp elt)
                               (valid-parameter-name-p (first  elt))
                               (type-specifier-p       (second elt)))
                          t)
                         ((and (not *lambda-list-typed-p*)
                               (valid-parameter-name-p elt))
                          t)
                         (t
                          (return-from %lambda-list-type nil))))
        (&rest (if (valid-parameter-name-p elt)
                   (setf state :done)
                   (return-from %lambda-list-type nil)))
        (:done (return-from %lambda-list-type nil))))
    (eq state :done)))

(def-test type-identification-rest (:suite lambda-list)
  (is (eq 'rest (lambda-list-type '(&rest args))))
  (is (eq 'rest (lambda-list-type '(a b &rest c))))
  (is-error (lambda-list-type '(a 5)))
  (is-error (lambda-list-type '(a b &rest)))
  (is-error (lambda-list-type '(a b &rest c d)))
  (is (eq 'rest
          (lambda-list-type '((a string) &rest args)
                            :typed t)))
  (is-error (lambda-list-type '((a string) &rest (args number)) :typed t)))

(defmethod %defun-lambda-list ((type (eql 'rest)) (lambda-list list))
  (let ((rest-position (position '&rest lambda-list)))
    (if *lambda-list-typed-p*
        (values (append (mapcar 'first (subseq lambda-list 0 rest-position))
                        (subseq lambda-list rest-position))
                (append (mapcar #'second (subseq lambda-list 0 rest-position))
                        '(&rest)))
        (copy-list lambda-list))))

(def-test defun-lambda-list-rest (:suite defun-lambda-list)
  (is (equalp '(a b &rest c)
              (defun-lambda-list '(a b &rest c))))
  (is-error (defun-lambda-list '(a b &rest)))
  (destructuring-bind (first second third)
      (defun-lambda-list '(a &rest c))
    (is (eq first 'a))
    (is (eq second '&rest))
    (is (eq 'c third)))
  (destructuring-bind ((first second third fourth) type-list)
      (multiple-value-list (defun-lambda-list '((a string) (b number) &rest
                                                c)
                             :typed t))
    (is (eq first 'a))
    (is (eq second 'b))
    (is (eq third '&rest))
    (is (eq fourth 'c))
    (is (equalp type-list '(string number &rest)))))

(defmethod %defun-body ((type (eql 'rest)) (defun-lambda-list list))
  (assert (not *lambda-list-typed-p*))
  (let ((rest-position (position '&rest defun-lambda-list)))
    `(apply (nth-value 1 (retrieve-polymorph ',*name*
                                             ,@(subseq defun-lambda-list
                                                       0 rest-position)
                                             ,@(subseq defun-lambda-list
                                                       (1+ rest-position))))
            ,@(remove '&rest defun-lambda-list))))

(defmethod %sbcl-transform-body-args ((type (eql 'rest)) (typed-lambda-list list))
  (assert *lambda-list-typed-p*)
  (let ((rest-position (position '&rest typed-lambda-list)))
    (append (mapcar 'first (subseq typed-lambda-list 0 rest-position))
            (last typed-lambda-list))))

(defmethod %lambda-declarations ((type (eql 'rest)) (typed-lambda-list list))
  (assert *lambda-list-typed-p*)
  `(declare ,@(mapcar (lambda (elt)
                        `(type ,(second elt) ,(first elt)))
                      (subseq typed-lambda-list
                              0
                              (position '&rest typed-lambda-list)))))

(defmethod %type-list-compatible-p ((type (eql 'rest))
                                    (type-list list)
                                    (untyped-lambda-list list))
  (let ((rest-position (position '&rest untyped-lambda-list)))
    (cond ((member '&rest type-list)
           (<= rest-position (position '&rest type-list)))
          ((member '&key type-list)
           (<= rest-position (position '&key type-list)))
          (t
           (<= rest-position (length type-list))))))

(defmethod applicable-p-function ((type (eql 'rest)) (type-list list))
  (let* ((rest-position (position '&rest type-list))
         (param-list (append (mapcar #'type->param (subseq type-list 0 rest-position))
                             `(&rest ,(gensym)))))
    `(lambda ,param-list
       (declare (optimize speed)
                (ignore ,@(last param-list)))
       (if *compiler-macro-expanding-p*
           (and ,@(loop :for param :in (subseq param-list 0 rest-position)
                        :for type  :in (subseq type-list  0 rest-position)
                        :collect `(our-typep ,param ',type)))
           (and ,@(loop :for param :in (subseq param-list 0 rest-position)
                        :for type  :in (subseq type-list  0 rest-position)
                        :collect `(typep ,param ',type)))))))

(5am:def-suite type-list-intersect-rest :in type-list-intersect-p)

(defmethod %type-list-intersect-p ((type-1 (eql 'rest)) (type-2 (eql 'rest)) list-1 list-2)
  (let ((rest-position-1 (position '&rest list-1))
        (rest-position-2 (position '&rest list-2)))
    (every #'type-intersect-p
           (subseq list-1 0 (min rest-position-1 rest-position-2))
           (subseq list-2 0 (min rest-position-1 rest-position-2)))))

(def-test type-list-intersect-rest-&-rest (:suite type-list-intersect-rest)
  (5am:is-true  (type-list-intersect-p '(string string &rest) '(string array &rest)))
  (5am:is-true  (type-list-intersect-p '(string string &rest) '(string &rest)))
  (5am:is-false (type-list-intersect-p '(string string &rest) '(string number &rest))))

(defmethod %type-list-intersect-p ((type-1 (eql 'rest)) (type-2 (eql 'required)) list-1 list-2)
  (let ((rest-position (position '&rest  list-1))
        (list-2-length (length list-2)))
    (if (< list-2-length rest-position)
        nil
        (every #'type-intersect-p
               (subseq list-1 0 rest-position)
               (subseq list-2 0 rest-position)))))

(def-test type-list-intersect-rest-&-required (:suite type-list-intersect-rest)
  (5am:is-true  (type-list-intersect-p '(string string &rest) '(string array)))
  (5am:is-true  (type-list-intersect-p '(string &rest) '(string array)))
  (5am:is-false (type-list-intersect-p '(string string &rest) '(string)))
  (5am:is-false (type-list-intersect-p '(string string &rest) '(string number))))

;;; Ignore the case of required-optional against all others
;;; TODO: Simplify the below methods :D

(defmethod %type-list-intersect-p ((type-1 (eql 'rest))
                                   (type-2 (eql 'required-key))
                                   list-1 list-2)
  (let ((rest-position (position '&rest list-1))
        (key-position  (position '&key  list-2)))
    (if (< key-position rest-position)
        (and (every #'type-intersect-p
                    (subseq list-1 0 key-position)
                    (subseq list-2 0 key-position))
             (and (let ((rest (subseq list-1 key-position rest-position)))
                    (loop :for (name type) :in (subseq list-2 (1+ key-position))
                          :while rest
                          :for type-1 := (first rest)
                          :for type-2 := (second rest)
                          :always (typep name type-1)
                          :do (setq rest (cddr rest))))
                  (let ((rest      (subseq list-1 key-position rest-position))
                        (intersect nil))
                    (loop :for (name type) :in (subseq list-2 (1+ key-position))
                          :while (and rest (not intersect))
                          :for type-1 := (first rest)
                          :for type-2 := (second rest)
                          :do (if (and (typep name type-1)
                                       (type-intersect-p type type-2))
                                  (setq intersect t)))
                    intersect)))
        (every #'type-intersect-p
               (subseq list-1 0 rest-position)
               (subseq list-2 0 rest-position)))))

(def-test type-list-intersect-rest-&-required-key (:suite type-list-intersect-rest)
  (5am:is-true  (type-list-intersect-p '(string string &rest) '(string array &key)))
  (5am:is-true  (type-list-intersect-p '(string &rest) '(string array &key)))
  (5am:is-true  (type-list-intersect-p '(string keyword  &rest) '(string &key (:a string))))
  (5am:is-true  (type-list-intersect-p '(string keyword string  &rest)
                                       '(string &key (:a string))))
  (5am:is-true  (type-list-intersect-p '(string keyword string  &rest)
                                       '(string &key (:a number) (:b string))))
  (5am:is-false (type-list-intersect-p '(string keyword string number &rest)
                                       '(string &key (:a number) (:b string))))
  (5am:is-false (type-list-intersect-p '(string keyword string  &rest)
                                       '(string &key (:a number) (:b number))))
  (5am:is-false (type-list-intersect-p '(string keyword string  &rest)
                                       '(string &key (:a number))))
  (5am:is-false (type-list-intersect-p '(string keyword string number &rest)
                                       '(string &key (:a number) (:b string))))
  (5am:is-false (type-list-intersect-p '(string keyword &rest) '(string &key)))
  (5am:is-false (type-list-intersect-p '(string string  &rest) '(string &key)))
  (5am:is-false (type-list-intersect-p '(string string  &rest) '(string &key (:a string)))))

(defmethod %type-list-intersect-p ((type-1 (eql 'required))
                                   (type-2 (eql 'required-key))
                                   list-1 list-2)
  (let ((list-1-length (length list-1))
        (key-position  (position '&key  list-2)))
    (cond ((= key-position list-1-length)
           (every #'type-intersect-p
                  (subseq list-1 0 list-1-length)
                  (subseq list-2 0 list-1-length)))
          ((< list-1-length key-position)
           nil)
          ((< key-position list-1-length)
           (and (evenp (- list-1-length key-position))
                (every #'type-intersect-p
                       (subseq list-1 0 key-position)
                       (subseq list-2 0 key-position))
                (and (let ((rest (subseq list-1 key-position list-1-length)))
                       (loop :for (name type) :in (subseq list-2 (1+ key-position))
                             :while rest
                             :for type-1 := (first rest)
                             :for type-2 := (second rest)
                             :always (typep name type-1)
                             :do (setq rest (cddr rest))))
                     (let ((rest      (subseq list-1 key-position list-1-length))
                           (intersect nil))
                       (loop :for (name type) :in (subseq list-2 (1+ key-position))
                             :while (and rest (not intersect))
                             :for type-1 := (first rest)
                             :for type-2 := (second rest)
                             :do (if (and (typep name type-1)
                                          (type-intersect-p type type-2))
                                     (setq intersect t)))
                       intersect)))))))

(def-test type-list-intersect-required-&-required-key (:suite type-list-intersect-rest)
  (5am:is-true  (type-list-intersect-p '(string string) '(string array &key)))
  (5am:is-true  (type-list-intersect-p '(string keyword string)
                                       '(string &key (:a string))))
  (5am:is-true  (type-list-intersect-p '(string keyword string)
                                       '(string &key (:a number) (:b string))))
  (5am:is-false (type-list-intersect-p '(string keyword) '(string &key)))
  (5am:is-false (type-list-intersect-p '(string) '(string array &key)))
  (5am:is-false (type-list-intersect-p '(string keyword) '(string &key (:a string))))
  (5am:is-false (type-list-intersect-p '(string keyword string number)
                                       '(string &key (:a number) (:b string))))
  (5am:is-false (type-list-intersect-p '(string keyword string)
                                       '(string &key (:a number))))
  (5am:is-false (type-list-intersect-p '(string string) '(string &key)))
  (5am:is-false (type-list-intersect-p '(string string) '(string &key (:a string)))))

(defmethod %type-list-intersect-p ((type-1 (eql 'required)) (type-2 (eql 'rest)) list-1 list-2)
  (%type-list-intersect-p type-2 type-1 list-2 list-1))

(defmethod %type-list-intersect-p ((type-1 (eql 'required-key))
                                   (type-2 (eql 'rest))
                                   list-1 list-2)
  (%type-list-intersect-p type-2 type-1 list-2 list-1))

(defmethod %type-list-intersect-p ((type-1 (eql 'required-key))
                                   (type-2 (eql 'required))
                                   list-1 list-2)
  (%type-list-intersect-p type-2 type-1 list-2 list-1))

