(in-package :typed-dispatch)

(defmethod %lambda-list-type ((type (eql 'required-optional)) (lambda-list list))
  (let ((state :required))
    (dolist (elt lambda-list)
      (ecase state
        (:required (cond ((eq elt '&optional)
                          (setf state '&optional))
                         ((and (symbolp elt)
                               (not (member elt lambda-list-keywords)))
                          t)
                         (t
                          (return-from %lambda-list-type nil))))
        (&optional (cond ((and (symbolp elt)
                               (not (member elt lambda-list-keywords)))
                          t)
                         (t
                          (return-from %lambda-list-type nil))))))
    (eq state '&optional)))

(def-test type-identification-optional (:suite lambda-list)
  (is (eq 'required-optional (lambda-list-type '(&optional)))
      "(defun foo (&optional)) does compile")
  (is (eq 'required-optional (lambda-list-type '(a &optional)))
      "(defun foo (a &optional)) does compile")
  (is (eq 'required-optional (lambda-list-type '(a &optional b))))
  (is-error (lambda-list-type '(a &optional 5)))
  (is-error (lambda-list-type '(a &optional b &rest))))

(defmethod %defun-lambda-list ((type (eql 'required-optional)) (lambda-list list))
  (let ((state       :required)
        (return-list ()))
    (dolist (elt lambda-list)
      (ecase state
        (:required (cond ((eq elt '&optional)
                          (push '&optional return-list)
                          (setf state '&optional))
                         ((and (symbolp elt)
                               (not (member elt lambda-list-keywords)))
                          (push elt return-list))
                         (t
                          (return-from %defun-lambda-list nil))))
        (&optional (cond ((and (symbolp elt)
                               (not (member elt lambda-list-keywords)))
                          (push (list elt nil (gensym (symbol-name elt)))
                                return-list))
                         (t
                          (return-from %defun-lambda-list nil))))))
    (nreverse return-list)))

(def-test defun-lambda-list-optional (:suite defun-lambda-list)
  (is (equalp '(a b &optional)
              (defun-lambda-list '(a b &optional))))
  (5am:is-true (destructuring-bind (first second third fourth)
                   (defun-lambda-list '(a &optional c d))
                 (and (eq first 'a)
                      (eq second '&optional)
                      (eq 'c (first third))
                      (eq 'd (first fourth))))))

(defmethod %defun-body ((type (eql 'required-optional)) (defun-lambda-list list))
  (let ((state       :required)
        (return-list ()))
    (loop :for elt := (first defun-lambda-list)
          :until (eq elt '&optional)
          :do (unless (and (symbolp elt)
                           (not (member elt lambda-list-keywords)))
                (return-from %defun-body nil))
              (push elt return-list)
              (setf defun-lambda-list (rest defun-lambda-list)))
    (when (eq '&optional (first defun-lambda-list))
      (setf state             '&optional
            defun-lambda-list (rest defun-lambda-list))
      (labels ((optional-p-tree (optional-lambda-list)
                 (if (null optional-lambda-list)
                     ()
                     (destructuring-bind (sym default symp) (first optional-lambda-list)
                       (declare (ignore default))
                       `(if ,symp
                            (cons ,sym ,(optional-p-tree (rest optional-lambda-list)))
                            ())))))
        (let ((optional-p-tree (optional-p-tree defun-lambda-list)))
          (values `(let ((apply-list ,optional-p-tree))
                     (apply (nth-value 1 (apply 'retrieve-typed-function
                                                ',*name*
                                                ,@(reverse return-list)
                                                apply-list))
                            ,@(reverse return-list)
                            apply-list))
                  defun-lambda-list))))))

