(in-package typed-dispatch)

;; In this file, our main functions/macros are
;; DEFINE-LAMBDA-LIST-HELPER
;; - LAMBDA-LIST-TYPE
;;   - %LAMBDA-LIST-TYPE
;; - DEFUN-LAMBDA-LIST
;;   - %DEFUN-LAMBDA-LIST
;; - DEFUN-BODY

;; THE BASICS ==================================================================

(define-constant +lambda-list-types+
    (list 'required
          'required-optional
          'required-key)
  :test #'equalp)

(defun lambda-list-type-p (object)
  "Checks whhether the OBJECT is in +LAMBDA-LIST-TYPES+"
  (member object +lambda-list-types+))

(deftype lambda-list-type () `(satisfies lambda-list-type-p))

(5am:def-suite lambda-list :in :typed-dispatch)

(defun potential-type-of-lambda-list (lambda-list)
  ;; "potential" because it does not check the symbols
  (declare (type list lambda-list))
  (the lambda-list-type
       (let ((intersection (intersection lambda-list lambda-list-keywords)))
         ;; premature optimization and over-abstraction:/
         (cond ((null intersection)
                'required)
               ((and (car intersection) (null (cdr intersection)) ; length is 1
                     (member '&optional intersection))
                'required-optional)
               ((and (car intersection) (null (cdr intersection)) ; length is 1
                     (member '&key intersection))
                'required-key)
               (t
                (error "Neither of ~A types" +lambda-list-types+))))))

(defvar *potential-type*)
(setf (documentation '*potential-type* 'variable)
      "POTENTIAL-TYPE of the LAMBDA-LIST of the typed function being compiled.
Bound inside the functions defined by TYPED-DISPATCH::DEFINE-LAMBDA-LIST-HELPER")

(defvar *lambda-list*)
(setf (documentation '*lambda-list* 'variable)
      "LAMBDA-LIST of the typed function being compiled. Bound inside the functions
defined by TYPED-DISPATCH::DEFINE-LAMBDA-LIST-HELPER")

(defvar *name*)
(setf (documentation '*name* 'variable)
      "NAME of the typed function being compiled. Bound inside DEFINE-TYPED-FUNCTION")

(defmacro define-lambda-list-helper ((outer-name outer-documentation)
                                     (inner-name inner-documentation)
                                     &body action-form)
  "ACTION-FORM should be defined in terms of *POTENTIAL-TYPE* and *LAMBDA-LIST* variables."
  `(progn
     (defun ,outer-name (lambda-list)
       ,outer-documentation
       (declare (type list lambda-list))
       (let ((*potential-type* (potential-type-of-lambda-list lambda-list))
             (*lambda-list*    lambda-list))
         (if (%lambda-list-type *potential-type* lambda-list)
             (progn ,@action-form)
             (error "LAMBDA-LIST ~A is neither of ~%  ~A" lambda-list +lambda-list-types+))))
     (defgeneric ,inner-name (potential-lambda-list-type lambda-list)
       (:documentation ,inner-documentation))
     ;; For better error reporting
     (defmethod ,inner-name ((type t) (lambda-list t))
       (assert (typep type 'lambda-list-type)
               ()
               "Expected POTENTIAL-LAMBDA-LIST-TYPE to be one of ~%  ~A~%but is ~A"
               +lambda-list-types+ type)
       (assert (typep lambda-list 'list)
               ()
               "Expected LAMBDA-LIST to be a LIST but is ~A"
               lambda-list)
       (error "No potential type found for LAMBDA-LIST ~A from amongst ~%  ~A"
              lambda-list +lambda-list-types+))))

;; LAMBDA-LIST-TYPE ============================================================

(define-constant +lambda-list-type-doc+
  "Returns the type of LAMBDA-LIST from amongst +LAMBDA-LIST-TYPES+.
Raises an ERROR otherwise."
  :test 'string=)

(define-lambda-list-helper
    (lambda-list-type  #.+lambda-list-type-doc+)
    (%lambda-list-type "Checks whether LAMBDA-LIST is of type POTENTIAL-LAMBDA-LIST-TYPE")
  *potential-type*)

(def-test type-identification (:suite lambda-list)
  (is (eq 'required (lambda-list-type '(a b))))
  (is-error (lambda-list-type '(a 5)))
  (is-error (lambda-list-type '(a b &rest))))

;; DEFUN-LAMBDA-LIST ===========================================================

(define-constant +defun-lambda-list-doc+
  "Processes LAMBDA-LIST to return another lambda-list suitable for the DEFUN generated by the DEFINE-TYPED-FUNCTION. Raises an error if %LAMBDA-LIST-TYPE fails on *POTENTIAL-TYPE*."
  :test 'string=)

(define-constant +defun-lambda-list-doc-helper+
  "Processes LAMBDA-LIST assuming it is of type TYPE, and returns another lambda-list that is suitable for the DEFUN generated by the DEFINE-TYPED-FUNCTION."
  :test 'string=)

(define-lambda-list-helper
    (defun-lambda-list  #.+defun-lambda-list-doc+)
    (%defun-lambda-list #.+defun-lambda-list-doc-helper+)
  (%defun-lambda-list *potential-type* *lambda-list*))

(5am:def-suite defun-lambda-list :in lambda-list)

;; DEFUN-BODY =========================================================

(define-constant +defun-body-doc+
  "Processes LAMBDA-LIST to return code suitable for the caller part
inside the DEFUN generated by the DEFINE-TYPED-FUNCTION. Raises an error if
%LAMBDA-LIST-TYPE fails on *POTENTIAL-TYPE*."
  :test 'string=)

(define-constant +defun-body-doc-helper+
  "Processes LAMBDA-LIST assuming it is of type TYPE, and returns code that is
is suitable for caller part inside DEFUN generated by the DEFINE-TYPED-FUNCTION."
  :test 'string=)

(define-lambda-list-helper
    (defun-body  #.+defun-body-doc+)
    (%defun-body #.+defun-body-doc-helper+)
  (let ((defun-lambda-list (%defun-lambda-list *potential-type* *lambda-list*)))
    (values (%defun-body *potential-type* defun-lambda-list)
            defun-lambda-list)))
