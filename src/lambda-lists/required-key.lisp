(in-package :typed-dispatch)

(defmethod %lambda-list-type ((type (eql 'required-key)) (lambda-list list))
  (let ((state :required))
    (dolist (elt lambda-list)
      (ecase state
        (:required (cond ((eq elt '&key)
                          (setf state '&key))
                         ((and (symbolp elt)
                               (not (member elt lambda-list-keywords)))
                          t)
                         (t
                          (return-from %lambda-list-type nil))))
        (&key (cond ((and (symbolp elt)
                          (not (member elt lambda-list-keywords)))
                     t)
                    (t
                     (return-from %lambda-list-type nil))))))
    (eq state '&key)))

(def-test type-identification-key (:suite lambda-list)
  (is (eq 'required-key (lambda-list-type '(&key)))
      "(defun foo (&key)) does compile")
  (is (eq 'required-key (lambda-list-type '(a &key)))
      "(defun foo (a &key)) does compile")
  (is (eq 'required-key (lambda-list-type '(a &key b))))
  (is-error (lambda-list-type '(a &key 5)))
  (is-error (lambda-list-type '(a &rest c &key b))))

(defmethod %defun-lambda-list ((type (eql 'required-key)) (lambda-list list))
  (let ((state       :required)
        (return-list ()))
    (dolist (elt lambda-list)
      (ecase state
        (:required (cond ((eq elt '&key)
                          (push '&key return-list)
                          (setf state '&key))
                         ((and (symbolp elt)
                               (not (member elt lambda-list-keywords)))
                          (push elt return-list))
                         (t
                          (return-from %defun-lambda-list nil))))
        (&key (cond ((and (symbolp elt)
                          (not (member elt lambda-list-keywords)))
                     (push (list elt nil (gensym (symbol-name elt)))
                           return-list))
                    (t
                     (return-from %defun-lambda-list nil))))))
    (nreverse return-list)))

(def-test defun-lambda-list-key (:suite defun-lambda-list)
  (is (equalp '(a b &key)
              (defun-lambda-list '(a b &key))))
  (5am:is-true (destructuring-bind (first second third fourth)
                   (defun-lambda-list '(a &key c d))
                 (and (eq first 'a)
                      (eq second '&key)
                      (eq 'c (first third))
                      (eq 'd (first fourth))))))

(defmethod %defun-body ((type (eql 'required-key)) (defun-lambda-list list))
  (let ((state       :required)
        (return-list ()))
    (loop :for elt := (first defun-lambda-list)
          :until (eq elt '&key)
          :do (unless (and (symbolp elt)
                           (not (member elt lambda-list-keywords)))
                (return-from %defun-body nil))
              (push elt return-list)
              (setf defun-lambda-list (rest defun-lambda-list)))
    (when (eq '&key (first defun-lambda-list))
      (setf state             '&key
            defun-lambda-list (rest defun-lambda-list))
      (labels ((key-p-tree (key-lambda-list)
                 (if (null key-lambda-list)
                     ()
                     (destructuring-bind (sym default symp) (first key-lambda-list)
                       (declare (ignore default))
                       (let ((recurse-result (key-p-tree (rest key-lambda-list))))
                         `(if ,symp
                              (cons ,(intern (symbol-name sym) :keyword)
                                    (cons ,sym ,recurse-result))
                              ,recurse-result))))))
        (let ((key-p-tree (key-p-tree defun-lambda-list)))
          (values `(let ((apply-list ,key-p-tree))
                     (apply (nth-value 1 (apply 'retrieve-typed-function
                                              ',*name*
                                              ,@(reverse return-list)
                                              apply-list))
                            ,@(reverse return-list)
                            apply-list))
                  defun-lambda-list))))))

