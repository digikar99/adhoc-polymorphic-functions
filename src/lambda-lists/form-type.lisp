(in-package :typed-functions)

(defun form-type (form &optional environment)
  "Returns two values: the first value is the TYPE of FORM if the second value is T"
  (cond ((constantp form environment)
         (values (type-of (constant-form-value form environment))
                 t))
        ((symbolp form)
         (values (introspect-environment:variable-type form environment)
                 (cdr (assoc 'type
                             (nth-value 2
                                        (variable-information form *environment*))))))
        ((listp form)
         (let ((first (first form)))
           (cond ((typep first 'function-name)
                  (cond ((macro-function first environment)
                         (form-type (macroexpand form environment)
                                    environment))
                        ((compiler-macro-function first environment)
                         (form-type (compiler-macroexpand form environment)
                                    environment))
                        ((special-operator-p first)
                         (cond ((eq 'the first)
                                (second form))
                               (t (error "Non-exhaustive-2"))))
                        (t (error "Non-exhaustive!"))))
                 ((eq 'lambda (first first))
                  (let ((the-form (first (last first))))
                    (if (and (listp the-form)
                             (eq 'the (first the-form)))
                        (second the-form)
                        (error "Non-exhaustive-4"))))
                 (t (error "Non-exhaustive-3")))))
        (t
         (error "~%We shouldn't have reached here!"))))
