(in-package :typed-functions)

(defun form-type (form &optional environment)
  "Returns two values: the first value is the TYPE of FORM if the second value is T"
  (cond ((constantp form environment)
         (values (type-of (constant-form-value form environment))
                 t))
        ((symbolp form)
         (values (introspect-environment:variable-type form environment)
                 (cdr (assoc 'type
                             (nth-value 2
                                        (variable-information form *environment*))))))
        ((listp form)
         (values (let ((first (first form)))
                   (cond ((typep first 'function-name)
                          (cond ((macro-function first environment)
                                 (form-type (macroexpand form environment)
                                            environment))
                                ((compiler-macro-function first environment)
                                 (form-type (compiler-macroexpand form environment)
                                            environment))
                                ((special-operator-p first)
                                 (cond ((eq 'the first)
                                        (second form))
                                       (t (signal 'form-type-failure :form form))))
                                (t (signal 'form-type-failure :form form))))
                         ((eq 'lambda (first first))
                          (let ((the-form (first (last first))))
                            (if (and (listp the-form)
                                     (eq 'the (first the-form)))
                                (second the-form)
                                (signal 'form-type-failure :form form))))
                         (t (signal 'form-type-failure :form form))))
                 t))
        (t
         (error "~%We shouldn't have reached here!"))))
